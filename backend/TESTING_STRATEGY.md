# Estrategia de Testing - Fluxion AI Backend

## An√°lisis del Backend

### Archivos Principales Analizados

1. **main.py** (1610 l√≠neas) - API principal FastAPI
2. **forecast_pmp.py** (484 l√≠neas) - Modelo de forecast Promedio M√≥vil Ponderado
3. **simple_api.py** (382 l√≠neas) - API simplificada para ubicaciones/inventario
4. **start.py** (81 l√≠neas) - Script de inicio

---

## Priorizaci√≥n de Testing por L√≥gica de Negocio

### üî¥ **CR√çTICAS** (Alta Prioridad - Afectan directamente decisiones de negocio)

#### 1. **C√°lculo de Pedidos Sugeridos** (`main.py:1090-1360`)
**L√≥gica cr√≠tica:** Calcula autom√°ticamente qu√© productos pedir y en qu√© cantidad.

**Funciones a testear:**
- `calcular_pedido_sugerido()` - L√≠nea 1091
- L√≥gica de decisi√≥n de pedido (l√≠neas 1286-1298):
  ```python
  if stock_total < punto_reorden:
      cantidad_sugerida = (stock_maximo - stock_total) + pronostico_unid
  elif stock_total < stock_minimo:
      cantidad_sugerida = stock_maximo - stock_total
  elif stock_total < stock_seguridad:
      cantidad_sugerida = stock_maximo - stock_total
  ```

**Tests necesarios:**
- ‚úÖ Stock bajo punto de reorden ‚Üí sugiere correctamente
- ‚úÖ Stock bajo m√≠nimo ‚Üí calcula cantidad correcta
- ‚úÖ Stock bajo seguridad ‚Üí aplica regla correcta
- ‚úÖ Stock suficiente ‚Üí no sugiere pedido
- ‚úÖ Conversi√≥n de unidades a bultos es correcta
- ‚úÖ C√°lculo de pron√≥stico se integra correctamente
- ‚ùå Casos edge: stock negativo, divisiones por cero

#### 2. **Forecast de Ventas** (`forecast_pmp.py`)
**L√≥gica cr√≠tica:** Predice ventas futuras usando Promedio M√≥vil Ponderado.

**Funciones a testear:**
- `calcular_forecast_diario()` - L√≠nea 75
- `calcular_forecast_producto()` - L√≠nea 183
- `calcular_forecast_tienda()` - L√≠nea 296

**Tests necesarios:**
- ‚úÖ Pesos suman 1.0 (40% + 30% + 20% + 10% = 100%)
- ‚úÖ C√°lculo correcto con datos hist√≥ricos conocidos
- ‚úÖ Manejo de productos sin suficientes datos hist√≥ricos
- ‚úÖ Ajustes estacionales y de tendencia se aplican correctamente
- ‚úÖ Forecast diario por d√≠a de semana es correcto
- ‚úÖ Intervalo de confianza (¬±20%) se calcula bien
- ‚ùå Divisi√≥n por cero en c√°lculos de bultos
- ‚ùå Fechas fuera de rango

#### 3. **An√°lisis de Ventas** (`main.py:927-1065`)
**L√≥gica cr√≠tica:** C√°lculos estad√≠sticos sobre ventas hist√≥ricas.

**Funciones a testear:**
- `get_ventas_detail()` - L√≠nea 927
- Promedios diarios, por d√≠a de semana, a√±o anterior

**Tests necesarios:**
- ‚úÖ Promedio diario calcula correctamente
- ‚úÖ Promedio por d√≠a de semana es preciso
- ‚úÖ Comparaci√≥n a√±o anterior funciona
- ‚úÖ Porcentaje del total suma 100%
- ‚úÖ Conversi√≥n unidades/bultos es correcta
- ‚ùå Fechas inv√°lidas o fuera de rango

---

### üü° **IMPORTANTES** (Prioridad Media - Correctness de datos)

#### 4. **Conexi√≥n a DuckDB**
**Funci√≥n:** `get_db_connection()` - `main.py:48`

**Tests necesarios:**
- ‚úÖ Conexi√≥n exitosa cuando DB existe
- ‚úÖ HTTPException cuando DB no existe
- ‚úÖ Path de DB correcto seg√∫n DATABASE_PATH env var
- ‚úÖ Cierre de conexi√≥n despu√©s de queries

#### 5. **ETL Sync Background** (`main.py:634-773`)
**L√≥gica:** Ejecuta ETL en background sin bloquear API.

**Tests necesarios:**
- ‚úÖ No permite ejecutar ETL simult√°neamente
- ‚úÖ Actualiza status correctamente durante ejecuci√≥n
- ‚úÖ Timeout despu√©s de 10 minutos funciona
- ‚úÖ Maneja errores del proceso ETL
- ‚úÖ Parsea correctamente resultados por tienda

#### 6. **Guardar Pedido** (`main.py:1395-1484`)
**L√≥gica:** Persiste pedidos sugeridos en DB.

**Tests necesarios:**
- ‚úÖ Genera n√∫mero de pedido secuencial correctamente
- ‚úÖ Calcula totales correctamente (productos, bultos, unidades)
- ‚úÖ Inserta en ambas tablas (pedidos + detalle)
- ‚úÖ Filtra solo productos incluidos
- ‚úÖ Maneja transacciones correctamente

---

### üü¢ **B√ÅSICAS** (Prioridad Baja - CRUD simple)

#### 7. **Endpoints CRUD b√°sicos**
- `get_ubicaciones()` - L√≠nea 228
- `get_productos()` - L√≠nea 365
- `get_categorias()` - L√≠nea 408
- `get_stock()` - L√≠nea 431

**Tests necesarios:**
- ‚úÖ Retornan datos cuando existen
- ‚úÖ Filtros funcionan correctamente
- ‚úÖ Paginaci√≥n funciona (si aplica)
- ‚úÖ Manejo de registros vac√≠os

---

## Plan de Implementaci√≥n

### Fase 1: Setup de Testing (1 d√≠a)
```bash
backend/
‚îú‚îÄ‚îÄ tests/
‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îú‚îÄ‚îÄ conftest.py          # Fixtures compartidos
‚îÇ   ‚îú‚îÄ‚îÄ test_database.py     # Tests de conexi√≥n DB
‚îÇ   ‚îî‚îÄ‚îÄ fixtures/
‚îÇ       ‚îî‚îÄ‚îÄ sample_data.sql  # Datos de prueba
‚îú‚îÄ‚îÄ pytest.ini
‚îî‚îÄ‚îÄ requirements-dev.txt
```

**Dependencias a instalar:**
```txt
pytest==7.4.3
pytest-asyncio==0.21.1
pytest-cov==4.1.0
httpx==0.25.1          # Para TestClient async
faker==20.0.3          # Para generar datos de prueba
freezegun==1.4.0       # Para mockear fechas
```

### Fase 2: Tests Cr√≠ticos - Pedidos Sugeridos (2 d√≠as)

**Archivo:** `tests/test_pedidos_sugeridos.py`

Casos de prueba:
1. ‚úÖ Stock cr√≠tico (bajo punto reorden) ‚Üí pedido correcto
2. ‚úÖ Stock bajo m√≠nimo ‚Üí cantidad exacta
3. ‚úÖ Stock suficiente ‚Üí no pedido
4. ‚úÖ Conversi√≥n unidades/bultos ‚Üí redondeo correcto
5. ‚úÖ Integraci√≥n con forecast ‚Üí usa pron√≥stico
6. ‚ùå Stock negativo ‚Üí manejo de error
7. ‚ùå Producto sin ventas ‚Üí comportamiento definido
8. ‚ùå Divisi√≥n por cero en bultos ‚Üí prevenci√≥n

### Fase 3: Tests Cr√≠ticos - Forecast (2 d√≠as)

**Archivo:** `tests/test_forecast_pmp.py`

Casos de prueba:
1. ‚úÖ Pesos suman 100%
2. ‚úÖ Forecast con 4 semanas completas
3. ‚úÖ Forecast con solo 2 semanas (datos limitados)
4. ‚úÖ Forecast diario por d√≠a de semana
5. ‚úÖ Ajustes estacionales aplicados
6. ‚úÖ Intervalo confianza ¬±20%
7. ‚ùå Sin datos hist√≥ricos ‚Üí error manejado
8. ‚ùå Fechas futuras inv√°lidas

### Fase 4: Tests Cr√≠ticos - An√°lisis Ventas (1 d√≠a)

**Archivo:** `tests/test_ventas_analysis.py`

Casos de prueba:
1. ‚úÖ Promedio diario correcto
2. ‚úÖ Promedio d√≠a de semana (ej: todos los lunes)
3. ‚úÖ Comparaci√≥n a√±o anterior
4. ‚úÖ Porcentaje del total suma 100%
5. ‚ùå Rango de fechas inv√°lido

### Fase 5: Tests Importantes - ETL & Persistencia (1 d√≠a)

**Archivo:** `tests/test_etl_background.py` y `tests/test_pedidos_guardado.py`

### Fase 6: Tests B√°sicos - CRUD (1 d√≠a)

**Archivo:** `tests/test_crud_endpoints.py`

---

## Fixtures Clave (`conftest.py`)

```python
import pytest
from pathlib import Path
import duckdb
from fastapi.testclient import TestClient

@pytest.fixture(scope="session")
def test_db_path(tmp_path_factory):
    """Crea una DB temporal para tests"""
    db_path = tmp_path_factory.mktemp("data") / "test_fluxion.db"

    # Crear DB y poblar con datos de prueba
    conn = duckdb.connect(str(db_path))

    # Ejecutar schema
    schema_path = Path(__file__).parent.parent.parent / "database" / "schema_extended.sql"
    with open(schema_path) as f:
        conn.execute(f.read())

    # Poblar con datos de prueba
    conn.execute("""
        INSERT INTO ventas_raw (ubicacion_id, codigo_producto, cantidad_vendida, fecha, ...)
        VALUES
            ('tienda_01', '000658', 10, '2024-01-01', ...),
            ...
    """)

    conn.close()
    yield db_path

@pytest.fixture
def client(test_db_path, monkeypatch):
    """Cliente de prueba con DB temporal"""
    monkeypatch.setenv("DATABASE_PATH", str(test_db_path))

    from backend.main import app
    return TestClient(app)

@pytest.fixture
def sample_ventas_data():
    """Datos de ventas de prueba conocidos"""
    return {
        "ubicacion_id": "tienda_01",
        "codigo_producto": "000658",
        "ventas_semana1": 100,  # 40% peso
        "ventas_semana2": 80,   # 30% peso
        "ventas_semana3": 60,   # 20% peso
        "ventas_semana4": 40,   # 10% peso
        # Forecast esperado = (100*0.4 + 80*0.3 + 60*0.2 + 40*0.1) / 7 dias
        "forecast_diario_esperado": 11.43
    }
```

---

## Ejemplo de Test Espec√≠fico

### `tests/test_pedidos_sugeridos.py`

```python
import pytest
from fastapi.testclient import TestClient

class TestPedidosSugeridos:
    """Tests para la l√≥gica de c√°lculo de pedidos sugeridos"""

    def test_stock_bajo_punto_reorden_genera_pedido(self, client, test_db_path):
        """
        DADO un producto con:
        - Stock actual: 10 unidades
        - Punto de reorden: 30 unidades
        - Stock m√°ximo: 100 unidades
        - Pron√≥stico 3 d√≠as: 15 unidades

        CUANDO se calcula el pedido sugerido

        ENTONCES debe sugerir: (100 - 10) + 15 = 105 unidades
        Y la raz√≥n debe ser "Stock bajo punto de reorden"
        """
        # Arrange
        conn = duckdb.connect(str(test_db_path))
        conn.execute("""
            INSERT INTO inventario_raw (
                ubicacion_id, codigo_producto, cantidad_actual,
                stock_minimo, stock_maximo, punto_reorden, cantidad_bultos
            ) VALUES ('tienda_01', 'PROD_TEST', 10, 20, 100, 30, 6)
        """)

        # Mock de ventas para generar pron√≥stico de 15 unidades/3d√≠as
        conn.execute("""
            INSERT INTO ventas_raw (ubicacion_id, codigo_producto, cantidad_vendida, fecha, dia_semana)
            VALUES
                ('tienda_01', 'PROD_TEST', 5, '2024-01-01', 1),
                ('tienda_01', 'PROD_TEST', 5, '2024-01-02', 2),
                ...
        """)
        conn.close()

        # Act
        response = client.post("/api/pedidos-sugeridos/calcular", json={
            "cedi_origen": "cedi_seco",
            "tienda_destino": "tienda_01",
            "dias_cobertura": 3
        })

        # Assert
        assert response.status_code == 200
        productos = response.json()

        producto_test = [p for p in productos if p["codigo_producto"] == "PROD_TEST"][0]

        assert producto_test["cantidad_sugerida_unid"] == 105
        assert producto_test["razon_pedido"] == "Stock bajo punto de reorden"
        assert producto_test["cantidad_ajustada_bultos"] == 18  # 105/6 = 17.5 ‚Üí 18 bultos

    def test_stock_suficiente_no_genera_pedido(self, client, test_db_path):
        """
        DADO un producto con stock suficiente (> stock_seguridad)
        CUANDO se calcula el pedido sugerido
        ENTONCES no debe sugerir pedido
        """
        # ... implementaci√≥n similar
        pass

    def test_conversion_bultos_redondea_correctamente(self, client):
        """
        DADO una cantidad sugerida de 107 unidades
        Y cantidad_bultos = 6 unidades/bulto
        CUANDO se convierte a bultos
        ENTONCES debe redondear a 18 bultos (107/6 = 17.83 ‚Üí 18)
        """
        # Test unitario de la l√≥gica de redondeo
        cantidad_sugerida = 107
        cantidad_bultos = 6

        cantidad_bultos_sugerida = cantidad_sugerida / cantidad_bultos
        cantidad_bultos_ajustada = int(cantidad_bultos_sugerida) + (
            1 if cantidad_bultos_sugerida % 1 >= 0.5 else 0
        )

        assert cantidad_bultos_ajustada == 18

    @pytest.mark.parametrize("stock_actual,punto_reorden,stock_minimo,stock_seguridad,razon_esperada", [
        (5, 30, 20, 30, "Stock bajo punto de reorden"),
        (15, 30, 20, 30, "Stock bajo m√≠nimo"),
        (25, 30, 20, 30, "Stock bajo seguridad"),
        (35, 30, 20, 30, "Stock suficiente"),
    ])
    def test_diferentes_niveles_stock_razon_correcta(
        self, client, stock_actual, punto_reorden, stock_minimo, stock_seguridad, razon_esperada
    ):
        """Test parametrizado para diferentes niveles de stock"""
        # ... implementaci√≥n
        pass
```

---

## M√©tricas de √âxito

### Coverage Objetivo
- **Funciones cr√≠ticas (forecast, pedidos):** 95%+ coverage
- **Funciones importantes (ETL, guardado):** 85%+ coverage
- **Funciones b√°sicas (CRUD):** 70%+ coverage
- **Coverage total backend:** 80%+

### Comando para ejecutar
```bash
cd backend
pytest tests/ -v --cov=. --cov-report=html --cov-report=term
```

### CI/CD Integration
Agregar a GitHub Actions:
```yaml
- name: Run Backend Tests
  run: |
    cd backend
    pip install -r requirements-dev.txt
    pytest tests/ --cov=. --cov-report=xml

- name: Upload Coverage
  uses: codecov/codecov-action@v3
```

---

## Riesgos y Consideraciones

### ‚ö†Ô∏è Riesgos Detectados en el C√≥digo

1. **Divisi√≥n por cero** (forecast_pmp.py:170, 275)
   ```python
   forecast_bultos = forecast_unidades / float(unid_bulto) if unid_bulto > 0 else 0.0
   ```
   ‚úÖ **Ya tiene protecci√≥n**

2. **SQL Injection en queries din√°micas** (main.py:1108-1267)
   ```python
   query = f"""
   WHERE v.ubicacion_id = '{request.tienda_destino}'
   ```
   ‚ö†Ô∏è **Usar par√°metros preparados en lugar de f-strings**

3. **Timeout de ETL** (main.py:661)
   - Timeout fijo de 600s (10 min)
   - ‚úÖ Est√° manejado con asyncio.TimeoutError

4. **N√∫meros de pedido no concurrentes** (main.py:1414-1417)
   ```python
   resultado = conn.execute("SELECT MAX(numero_pedido)...")
   siguiente_numero = int(ultimo_numero.split('-')[1]) + 1
   ```
   ‚ö†Ô∏è **Race condition posible si hay requests simult√°neas**

---

## Siguientes Pasos

1. ‚úÖ Revisar y aprobar esta estrategia
2. ‚öôÔ∏è Crear estructura de tests (`tests/` folder)
3. üì¶ Instalar dependencias de testing
4. üß™ Implementar tests de Fase 1 (Setup)
5. üî¥ Implementar tests cr√≠ticos (Fases 2-4)
6. üü° Implementar tests importantes (Fase 5)
7. üü¢ Implementar tests b√°sicos (Fase 6)
8. üìä Generar reporte de coverage
9. üîÑ Integrar en CI/CD

---

## Tiempo Estimado Total

- **Setup inicial:** 1 d√≠a
- **Tests cr√≠ticos:** 5 d√≠as
- **Tests importantes:** 1 d√≠a
- **Tests b√°sicos:** 1 d√≠a
- **Refactoring y fixes:** 1 d√≠a
- **Documentaci√≥n:** 0.5 d√≠as

**Total: ~9.5 d√≠as** de desarrollo

---

## Beneficios Esperados

1. ‚úÖ **Confianza en l√≥gica de negocio:** Tests verifican que c√°lculos cr√≠ticos (pedidos, forecast) son correctos
2. ‚úÖ **Prevenci√≥n de regresiones:** Cambios futuros no rompen l√≥gica existente
3. ‚úÖ **Documentaci√≥n viva:** Tests sirven como ejemplos de uso
4. ‚úÖ **Deployment seguro:** CI/CD bloquea merges con tests fallidos
5. ‚úÖ **Debugging m√°s r√°pido:** Tests a√≠slan problemas espec√≠ficos
6. ‚úÖ **Refactoring seguro:** Permite mejorar c√≥digo sin miedo a romper funcionalidad
